<!DOCTYPE html>
<html>

<head>
  <style>
    /* layout */
    div {
      margin-bottom: 0.5em;
    }

    #main-toolbar,
    #secondary-toolbar {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    /* monospace helpers */
    .mono {
      white-space: pre-line;
      font-family: Consolas, monospace;
      font-size: 12px;
      color: #333;
    }

    .mono-dim {
      color: #444;
    }

    /* folder action buttons */
    .folder-btn {
      font-family: Consolas, monospace;
      font-size: 12px;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .folder-btn.excluded {
      background: #fdd;
    }

    /* tags */
    #tags-container {
      display: none;
    }

    #tags {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .tag-chip {
      font-family: Consolas, monospace;
      font-size: 11px;
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid #cfe;
      background: #eef;
      color: #224;
    }
  </style>
</head>

<body>
  <div id="main-toolbar">
    <button id="btn-delete" title="Delete selected files">Delete</button>
  </div>
  <div id="secondary-toolbar"></div>
  <hr />
  <div id="file-info">
    <div id="sel-summary">(none)</div>
    <div id="sel-name" class="mono" style="display:none"></div>
    <div id="sel-path" class="mono mono-dim">(no path)</div>
    <div id="tags"></div>
  </div>
  <hr />
  <div id="file-actions">
  </div>
  <script type="module">
    // script type="module" so we can use await

    // DOM refs
    const els = {
      summary: document.querySelector( '#sel-summary' ),
      name: document.querySelector( '#sel-name' ),
      path: document.querySelector( '#sel-path' ),
      actions: document.querySelector( '#file-actions' ),
      secondary: document.querySelector( '#secondary-toolbar' ),
      btnDelete: document.querySelector( '#btn-delete' ),
      tagsContainer: ( () => {
        // create Tags section dynamically so we don't disturb layout too much
        const fileInfo = document.querySelector( '#file-info' );
        const wrap = document.createElement( 'div' );
        wrap.id = 'tags-container';
        const label = document.createElement( 'div' );
        label.className = 'mono-dim';
        label.textContent = 'Tags:';
        const tags = document.createElement( 'div' );
        tags.id = 'tags';
        wrap.appendChild( label );
        wrap.appendChild( tags );
        fileInfo.after( wrap );
        return wrap;
      } )(),
      tags: null
    };
    els.tags = document.querySelector( '#tags' );

    // Helpers
    const setExcludedStyle = ( btn, excluded ) => {
      btn.classList.toggle( 'excluded', !!excluded );
    };

    async function isExcluded ( folder ) {
      const curr = await ahk.getControlText( 'Edit1', 'ahk_class EVERYTHING_(1.5a)' );
      // Everything exclusion syntax for a path: !"C:\\Path"
      const excl = `!"${ folder }"`;
      return !!curr && curr.includes( excl );
    }

    function renderFolderButtons ( items ) {
      if ( !items?.length ) { els.actions.innerHTML = ''; return; }
      els.actions.innerHTML = '';
      const btns = document.createElement( 'div' );
      btns.style.display = 'flex';
      btns.style.flexDirection = 'column';
      btns.style.gap = '2px';
      items.forEach( ( folder ) => {
        const row = document.createElement( 'div' );
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';

        // Folder path label
        const folderLabel = document.createElement( 'span' );
        folderLabel.className = 'mono';
        folderLabel.textContent = folder;
        row.appendChild( folderLabel );

        // Buttons container
        const btnGroup = document.createElement( 'span' );
        btnGroup.style.display = 'flex';
        btnGroup.style.gap = '4px';

        // Exclude button
        const btnExclude = document.createElement( 'button' );
        btnExclude.className = 'folder-btn';
        btnExclude.textContent = 'Exclude';
        btnExclude.title = `Toggle exclusion for ${ folder }`;
        ( async () => setExcludedStyle( btnExclude, await isExcluded( folder ) ) )();
        btnExclude.addEventListener( 'click', async () => {
          await ahk.global.ToggleExcludeFolder( folder );
          setExcludedStyle( btnExclude, await isExcluded( folder ) );
        } );

        // Search-only button
        const btnOnly = document.createElement( 'button' );
        btnOnly.className = 'folder-btn only';
        btnOnly.textContent = 'Only';
        btnOnly.title = `Toggle search only in ${ folder }`;
        btnOnly.dataset.active = 'false';
        function setOnlyStyle ( active ) {
          btnOnly.style.background = active ? '#dfd' : '';
        }
        btnOnly.addEventListener( 'click', async () => {
          const isActive = btnOnly.dataset.active === 'true';
          btnOnly.dataset.active = ( !isActive ).toString();
          setOnlyStyle( !isActive );
          if ( !isActive ) {
            if ( window.ahk?.global?.SetSearchOnlyFolder ) {
              await ahk.global.SetSearchOnlyFolder( folder );
            }
          } else {
            if ( window.ahk?.global?.ClearSearchOnlyFolder ) {
              await ahk.global.ClearSearchOnlyFolder( folder );
            }
          }
        } );
        setOnlyStyle( false );

        btnGroup.appendChild( btnExclude );
        btnGroup.appendChild( btnOnly );
        row.appendChild( btnGroup );
        btns.appendChild( row );
      } );
      els.actions.appendChild( btns );
    }

    // Tag extraction and rendering
    function extractTagsFromName ( name ) {
      if ( !name ) return [];
      const matches = [ ...name.matchAll( /\[(.+?)\]/g ) ];
      const tags = matches.map( match => match[ 1 ] );
      return tags;
    }
    function extractTagsFromNamesList ( namesList ) {
      const counts = new Map();
      for ( const nm of namesList ) {
        for ( const t of extractTagsFromName( nm ) ) {
          counts.set( t, ( counts.get( t ) || 0 ) + 1 );
        }
      }
      // Return unique tags sorted alphabetically
      const output = Array.from( counts.keys() ).sort( ( a, b ) => a.localeCompare( b ) );
      return output;
    }
    function renderTags ( tags ) {
      if ( tags && tags.length ) {
        els.tags.innerHTML = '';
        for ( const t of tags ) {
          const chip = document.createElement( 'span' );
          chip.className = 'tag-chip';
          chip.textContent = t;
          els.tags.appendChild( chip );
        }
        els.tagsContainer.style.display = '';
      } else {
        els.tags.innerHTML = '';
        els.tagsContainer.style.display = 'none';
      }
    }

    // Render current selection from AHK globals
    async function renderSelection () {
      try {
        const [ fileName, filePath, namesAll, countRaw, folderChain ] = await Promise.all( [
          ahk.global.SelectedFileName,
          ahk.global.SelectedFilePath,
          ahk.global.SelectedNames,
          ahk.global.SelectedCount,
          ahk.global.SelectedFolderPaths,
        ] );
        const count = Number( countRaw ) || 0;
        if ( count > 1 ) {
          els.summary.innerText = `${ count } items selected`;
          els.name.style.display = '';
          els.name.innerText = ( namesAll || '' ).split( '\n' ).slice( 0, 10 ).join( '\n' );
          els.path.innerText = '(multiple paths)';
          els.actions.innerHTML = '';
          const allNames = ( namesAll || '' ).split( '\n' ).filter( Boolean );
          renderTags( extractTagsFromNamesList( allNames ) );
          return;
        }
        if ( count === 1 || ( fileName && fileName.trim() ) ) {
          els.summary.innerText = '1 item selected';
          els.name.style.display = '';
          els.name.innerText = fileName || '';
          els.path.innerText = filePath && filePath.trim() ? filePath : '(no path)';
          const items = folderChain ? folderChain.split( '\n' ) : [];
          renderFolderButtons( items );
          renderTags( extractTagsFromNamesList( [ fileName || '' ] ) );
          return;
        }
        // none selected
        els.summary.innerText = '(none)';
        els.name.style.display = 'none';
        els.name.innerText = '';
        els.path.innerText = '(no path)';
        els.actions.innerHTML = '';
        renderTags( [] );
      } catch { /* ignore if globals not yet available */ }
    }

    // Secondary toolbar: Exclude Folders toggle (!folder:)
    const btnExclude = document.createElement( 'button' );
    btnExclude.id = 'btn-exclude-folders';
    btnExclude.title = 'Exclude folders (!folder:)';
    btnExclude.textContent = 'Exclude Folders';
    els.secondary.appendChild( btnExclude );
    btnExclude.addEventListener( 'click', async () => {
      try { await ahk.global.ExcludeFolders(); } catch ( e ) { console.error( 'ExcludeFolders failed', e ); }
    } );

    // Delete button state and action
    async function updateDeleteState () {
      try {
        const [ countRaw, filePath ] = await Promise.all( [
          ahk.global.SelectedCount,
          ahk.global.SelectedFilePath,
        ] );
        const count = Number( countRaw ) || 0;
        els.btnDelete.disabled = !( count > 0 || ( filePath && filePath.trim() ) );
      } catch { /* ignore */ }
    }
    els.btnDelete.addEventListener( 'click', async () => {
      try { await ahk.global.DeleteSelected(); } catch ( e ) { console.error( 'DeleteSelected failed', e ); }
    } );

    // Initial render and expose updater for AHK to call
    await renderSelection();
    await updateDeleteState();
    const oldUpdater = renderSelection;
    window.updateSelectedFromAhk = async () => { await oldUpdater(); await updateDeleteState(); };
  </script>
</body>

</html>